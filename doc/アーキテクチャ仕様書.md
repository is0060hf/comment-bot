# アーキテクチャ仕様書（YouTubeコメントBot）

- 版: v0.2
- 作成日: 2025-10-11
- 根拠: `doc/要件定義書.md`
- トポロジ: Next.js on Vercel（UI）＋ ローカルエージェント（処理/投稿）
- 投稿方針（A案）: ローカルがYouTubeへ直接投稿。

---

## 1. アーキテクチャスタイル
- レイヤード + ポート&アダプタ（Hexagonal）
- 目的: STT/LLM/プラットフォーム/モデレーション/設定の独立性と交換容易性

## 2. レイヤ構成
- interface
  - Web UI: Next.js（Vercel, App Router, Route Handlers/Server Actionsのみ）
  - CLI: ローカル操作
- application（ローカル）
  - 起動/停止/ポリシー適用/スケジューラ/設定反映
- domain（ローカル）
  - 機会検知、生成方針、モデレーション判定
- infrastructure
  - ローカル: STT/LLM/モデレーション/YouTube投稿アダプタ
  - Vercel: 設定配布のためのサーバーサイドAPI（秘密は保存しない）

## 3. 主要ポート/アダプタ
- Port（ローカル）: `SpeechToTextPort`, `LanguageModelPort`, `ModerationPort`, `ChatPlatformPort`, `ConfigPort`, `ClockPort`
- Adapter（ローカル）: `GcpSttAdapter`/`DeepgramSttAdapter`, `OpenAiLmAdapter`, `AzureSafetyAdapter`, `YouTubeChatAdapter`, `YamlConfigAdapter`
- Port（UI）: `RemoteConfigPort`（任意, 読取only推奨）
- Adapter（UI）: `VercelEdgeConfigAdapter` or `KVAdapter`（秘密/トークンは扱わない）

## 4. データモデル骨子（例）
- TranscriptSegment { text: string; isFinal: boolean; tsStartMs: number; tsEndMs: number }
- ContextSummary { topics: string[]; keyPhrases: string[]; lastUtterances: string[] }
- TriggerDecision { shouldComment: boolean; reason: string; confidence: number }
- GeneratedComment { text: string; source: "llm" | "template" }
- ModerationResult { approved: boolean; reason?: string }
- PostResult { success: boolean; messageId?: string; errorCode?: string; httpStatus?: number }

（注）型は厳格に定義し、`any`/`unknown`は使用しない。

## 5. シーケンス
1) Audio（ローカル） → STT → Context更新
2) Trigger判定（ルール→LLM分類）
3) 生成（LLM→テンプレート）
4) 安全フィルタ（外部API/ルール）
5) スケジューラ（レート/重複）
6) YouTube投稿（ローカルが直接, A案）
7) 設定更新（UI→サーバーサイド格納/配布）→ ローカルが同期

## 6. デプロイトポロジー
- Vercel（Next.js, Edge/Nodeランタイム）: 設定UI/配布のみ。長時間処理や常駐は行わない
- ローカル（macOS, Node.js）: 音声取り込み/認識/生成/投稿の全処理

## 7. レート制御/バックオフ（ローカル）
- `minIntervalSeconds`, `maxPer10Min`, `cooldownSeconds`
- 失敗時は指数バックオフ（1s→2s→4s…上限）

## 8. 構成管理
- ローカルYAMLを基準。任意でVercelのサーバーサイドから取得してマージ
- 秘密・トークンはローカルのみで保持（UI側では保存しない）

## 9. ログ/テレメトリ
- エラーのみ最小限保存（PIIマスク）。メトリクスはローカル・保存なし

## 10. セキュリティ
- OAuth秘密/トークンはローカルのみ
- クライアント直フェッチ禁止（UI→Route Handlers経由）

## 11. 停止手順
- CLI `stop` 時、起動中のWebサーバー/OAuthコールバックサーバーを必ずkill（ローカル）

## 12. 実装に必要な事項
- **ポート契約（関数の骨子）**
  - `SpeechToTextPort.start(config): Promise<void>` / `stop(): Promise<void>`（コールバックで`TranscriptSegment`供給）
  - `LanguageModelPort.generateComment(ctx): Promise<GeneratedComment>`
  - `LanguageModelPort.classifyNeed(ctx): Promise<TriggerDecision>`
  - `ModerationPort.moderate(text): Promise<ModerationResult>`
  - `ChatPlatformPort.postMessage(liveChatId, text): Promise<PostResult>`
  - `ChatPlatformPort.getLiveChatId(config): Promise<string>`（要確認）
  - `ConfigPort.load(): AppConfig` / `merge(remote): AppConfig`
- **アダプタ実装の留意点**
  - Google APIsクライアントの利用（認証/トークン更新/HTTP再試行）
  - STT/LLM/モデレーションSDKのタイムアウト/再試行/エラー分類
- **エラー分類/リトライ**
  - `Retryable`（5xx/429/ネットワーク）と`NonRetryable`（4xx）を厳密に分離
  - バックオフ: 1s→2s→4s→上限、Jitter付与
- **設定DI/依存性注入**
  - 起動時に`AppConfig`を検証→DIコンテナへバインド。UI配布設定はサニタイズ済みのみ
- **セキュリティ**
  - 秘密/トークンはローカルのみ。UI（Vercel）側に保存しない
  - クライアント直フェッチ禁止（Route Handlers/Server Actions経由）
- **デプロイ/動作制約**
  - Vercelは長時間処理不可→ローカルが常駐。UIは短時間リクエストのみ
  - 停止時はローカルのWebサーバー（OAuthコールバック）を必ずkill
